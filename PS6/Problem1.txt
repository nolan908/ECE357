Because the same spinlock is used in both some function and the signal handler, a problem can occur. If a signal handler runs while some_function is already holding the lock, the signal handler will run and try to grab spin_lock(&ms->lock) that will never be released until the interrupted code resumes. This causes a deadlock within the same thread. This is primary reason.

The signal_handler and some_function are also attempting to use the same spinlock at the same time. In both cases, the lock is being manually set back to 0. They do acquire the lock correctly with spin_lock(), but they “unlock” it a different way by writing ms->lock = 0 instead of calling spin_unlock(&ms->lock). 

To fix this, the signal handler must not try to get the same spinlock as the main code. Instead of calling spin_lock in signal_handler, the handler should record in a global variable (a "flag") that a SIGINT occurred. While holding the lock, the main code can check this flag and if it is set, carry out the work of the signal handler. This removes the deadlock and the handler no longer blocks on a lock that already been held.


