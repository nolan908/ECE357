The signal_handler and some_function are both using the same spinlock at the same time. In both cases, the lock is being manually set back to 0. They do acquire the lock correctly with spin_lock(), but they “unlock” it incorrectly by writing ms->lock = 0 instead of calling spin_unlock(&ms->lock). This bypasses all the atomic logic that a proper spinlock needs. 

Because the same spinlock is used in both normal code and the signal handler, a problem can occur. If the signal fires while some_function is already holding the lock, the signal handler will run and try to call spin_lock(&ms->lock) again. But the lock is still held by the interrupted thread. The handler then spins forever waiting for the lock to become free, causing a deadlock within the same thread.

This happens because spin_lock is not async-signal-safe. An async-signal-safe function can be safely called from a signal handler even if the signal interrupts that same function. spin_lock does not meet that requirement so it shouldn't be used inside a signal handler. 

In order to correct the issue, use spin_unlock(&ms->lock) within some_function. We should also not put a spinlock in the signal handler. We want the signal handler to do the bare minimum of sending a global flag and let the manipulation of the data structure do its job under the lock. Within the handler, we should just record that SIGINT happened. 

In some function, we say that the signal handler never takes the spinlock so there is no self-deadlock. All access to ms is protected under the spin_lock and spin_unlock pair. The patched version is in the other file called patchedPS1.c
