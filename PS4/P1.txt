1. To get a core dump when a program hangs, run ulimit, which enables core dumps before running the program. This lets the system save a core file when the program crashes. The file might go to the current directory, depending on the system. You can also see that if the program hangs but did not crash, you can attach a debugger like gdb. This saves a previously saved state of the program’s memory (registers, call stack, global variables, local variables) for debugging.
2. We can change the keyboard controls to change which character sends a signal, so that BACKSPACE could cause a signal like SIGINT or SIGQUIT to be sent to the process. This would make the program terminate. We would change the terminal settings, not the program itself.
3. We will return a partial write when there is a signal that interrupts the write() system call. If the data is already partially written,  the kernel returns the number of bytes that were written. If the code treats the short writes as an error, you will lose the remaining data. 
4. If a process is in an uninterruptible sleep and kill -9, it is waiting in the kernel for the disk I/O or device response. The process can’t handle any signals like kill -9 -> SIGKILL in the meantime, including processes that would kill it (SIGKILL), until the wait is over.
5. An interprocessor interrupt is an interrupt that one CPU sends to another CPU. It is used by the kernel to make another CPU do something like deliver a signal to a process running there, or handle efficient task management. Signals are supposed to be the communication between the processes, and the interprocessor interrupts are for communication between CPUs inside the kernel. 
